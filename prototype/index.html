<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>FREEFALL — Prototype</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Impact', 'Arial Black', sans-serif;
    touch-action: none;
  }
  #ui {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 10;
  }
  #level-num {
    position: absolute;
    top: 20px; left: 20px;
    color: rgba(255,255,255,0.5);
    font-size: 18px;
    font-family: monospace;
    letter-spacing: 2px;
  }
  #tap-hint {
    position: absolute;
    bottom: 60px;
    width: 100%;
    text-align: center;
    color: rgba(255,255,255,0.3);
    font-size: 14px;
    letter-spacing: 3px;
    font-family: 'Arial', sans-serif;
  }
  #word-reveal {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 72px;
    letter-spacing: 6px;
    color: #fff;
    text-shadow: 0 0 40px #00D4FF, 0 0 80px #00D4FF;
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    pointer-events: none;
  }
  #word-reveal.show { transform: translate(-50%, -50%) scale(1); }
  #next-btn {
    position: absolute;
    bottom: 40px; right: 30px;
    background: transparent;
    border: 1px solid #00D4FF;
    color: #00D4FF;
    font-size: 14px;
    letter-spacing: 2px;
    padding: 10px 20px;
    cursor: pointer;
    pointer-events: all;
    display: none;
    font-family: 'Impact', sans-serif;
  }
  canvas {
    display: block;
    max-width: 100vw;
    max-height: 100vh;
  }
</style>
</head>
<body>

<div id="ui">
  <div id="level-num">01</div>
  <div id="tap-hint">TAP TO START</div>
  <div id="word-reveal" id="word-reveal">CLEAN</div>
  <button id="next-btn" onclick="nextLevel()">NEXT LEVEL →</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const wordEl = document.getElementById('word-reveal');
const hintEl = document.getElementById('tap-hint');
const nextBtn = document.getElementById('next-btn');

// --- Sizing (portrait phone-like) ---
const W = Math.min(window.innerWidth, 430);
const H = Math.min(window.innerHeight, 932);
canvas.width = W;
canvas.height = H;

// --- Physics constants ---
const GRAVITY_MAG = 0.4;
const SPHERE_RADIUS = 14;
const LAUNCH_VX = 2.2;

// --- World colours ---
const WORLDS = [
  { name: 'THE BLOCK',    primary: '#00D4FF', trailA: '#00D4FF', trailB: '#FF1493', bgTop: '#050510', bgBot: '#0A0A2E' },
  { name: 'NEON YARD',    primary: '#39FF14', trailA: '#39FF14', trailB: '#FFE600', bgTop: '#050A05', bgBot: '#0A1A0A' },
  { name: 'UNDERGROUND',  primary: '#FF6600', trailA: '#FF6600', trailB: '#CC0000', bgTop: '#0A0500', bgBot: '#1A0800' },
  { name: 'STATIC',       primary: '#8B00FF', trailA: '#8B00FF', trailB: '#FFFFFF', bgTop: '#05000A', bgBot: '#0F000F' },
];

// --- Levels (normalized 0-1 coords) ---
const LEVELS = [
  // World 1
  {
    world: 0, level: 1,
    launchX: 0.08, launchY: 0.5, vx: LAUNCH_VX,
    goalX: 0.88, goalY: 0.5, goalR: 22,
    parFlips: 3,
    obstacles: [
      { x: 0.3, y: 0.0, w: 0.04, h: 0.38 },
      { x: 0.3, y: 0.62, w: 0.04, h: 0.38 },
      { x: 0.6, y: 0.2, w: 0.04, h: 0.35 },
      { x: 0.6, y: 0.65, w: 0.04, h: 0.35 },
    ]
  },
  {
    world: 0, level: 2,
    launchX: 0.08, launchY: 0.7, vx: LAUNCH_VX,
    goalX: 0.88, goalY: 0.3, goalR: 22,
    parFlips: 4,
    obstacles: [
      { x: 0.25, y: 0.0, w: 0.04, h: 0.45 },
      { x: 0.25, y: 0.6, w: 0.04, h: 0.4 },
      { x: 0.5,  y: 0.35, w: 0.04, h: 0.65 },
      { x: 0.72, y: 0.0, w: 0.04, h: 0.3 },
      { x: 0.72, y: 0.5, w: 0.04, h: 0.5 },
    ]
  },
  {
    world: 0, level: 3,
    launchX: 0.08, launchY: 0.5, vx: LAUNCH_VX * 0.9,
    goalX: 0.88, goalY: 0.15, goalR: 20,
    parFlips: 5,
    obstacles: [
      { x: 0.2,  y: 0.6, w: 0.5, h: 0.04 },
      { x: 0.45, y: 0.0, w: 0.04, h: 0.5 },
      { x: 0.65, y: 0.3, w: 0.04, h: 0.7 },
      { x: 0.0,  y: 0.3, w: 0.35, h: 0.04 },
    ]
  },
];

// --- State ---
let state = 'menu'; // menu | ready | playing | dead | complete
let currentLevelIdx = 0;
let gravityDir = 1; // 1 = down, -1 = up
let sphere = { x: 0, y: 0, vx: 0, vy: 0 };
let trail = []; // [{x,y,t}]
let scatterDots = [];
let flipCount = 0;
let distanceTravelled = 0;
let bgOffsetY = 0;
let deathTimer = 0;
let completeTimer = 0;
let particles = [];

function lerpColor(a, b, t) {
  const ah = a.replace('#','');
  const bh = b.replace('#','');
  const ar = parseInt(ah.slice(0,2),16), ag = parseInt(ah.slice(2,4),16), ab = parseInt(ah.slice(4,6),16);
  const br = parseInt(bh.slice(0,2),16), bg = parseInt(bh.slice(2,4),16), bb = parseInt(bh.slice(4,6),16);
  const r = Math.round(ar + (br-ar)*t);
  const g = Math.round(ag + (bg-ag)*t);
  const blue = Math.round(ab + (bb-ab)*t);
  return `rgb(${r},${g},${blue})`;
}

function hexToRgba(hex, a) {
  const h = hex.replace('#','');
  const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

function getLevel() { return LEVELS[currentLevelIdx % LEVELS.length]; }
function getWorld() { return WORLDS[getLevel().world]; }

function screenX(nx) { return nx * W; }
function screenY(ny) { return ny * H; }

function resetSphere() {
  const lv = getLevel();
  sphere.x = screenX(lv.launchX);
  sphere.y = screenY(lv.launchY);
  sphere.vx = lv.vx;
  sphere.vy = 0;
  gravityDir = 1;
  trail = [];
  scatterDots = [];
  flipCount = 0;
  distanceTravelled = 0;
  bgOffsetY = 0;
  particles = [];
}

function getTrailColor() {
  const world = getWorld();
  const t = Math.min(distanceTravelled / 900, 1);
  return lerpColor(world.trailA, world.trailB, t);
}

function spawnDeathParticles(x, y) {
  const world = getWorld();
  for (let i = 0; i < 16; i++) {
    const angle = (Math.PI * 2 / 16) * i + (Math.random()-0.5)*0.3;
    const speed = 2 + Math.random() * 4;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1.0,
      decay: 0.025 + Math.random()*0.02,
      color: world.primary,
      radius: 2 + Math.random()*3
    });
  }
}

function spawnGoalParticles(x, y) {
  for (let i = 0; i < 24; i++) {
    const angle = (Math.PI * 2 / 24) * i;
    const speed = 1.5 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1.0,
      decay: 0.018 + Math.random()*0.015,
      color: '#00FFFF',
      radius: 2 + Math.random()*3
    });
  }
}

function checkCollisions() {
  const lv = getLevel();
  const sx = sphere.x, sy = sphere.y;

  // Screen bounds
  if (sx < -20 || sx > W+20 || sy < -20 || sy > H+20) return 'dead';

  // Obstacles
  for (const obs of lv.obstacles) {
    const ox = screenX(obs.x), oy = screenY(obs.y);
    const ow = obs.w * W, oh = obs.h * H;
    if (sx+SPHERE_RADIUS > ox && sx-SPHERE_RADIUS < ox+ow &&
        sy+SPHERE_RADIUS > oy && sy-SPHERE_RADIUS < oy+oh) {
      return 'dead';
    }
  }

  // Goal
  const gx = screenX(lv.goalX), gy = screenY(lv.goalY);
  const dist = Math.sqrt((sx-gx)**2 + (sy-gy)**2);
  if (dist < lv.goalR + SPHERE_RADIUS) return 'complete';

  return null;
}

function getCompletionWord() {
  const lv = getLevel();
  const roll = Math.random();
  if (flipCount <= lv.parFlips) {
    return roll < 0.75 ? 'CLEAN' : 'FRESH';
  }
  if (roll < 0.40) return 'CLEAN';
  if (roll < 0.65) return 'FRESH';
  if (roll < 0.85) return 'DOPE';
  return 'NICE';
}

function nextLevel() {
  currentLevelIdx = (currentLevelIdx + 1) % LEVELS.length;
  wordEl.className = '';
  wordEl.style.transform = 'translate(-50%, -50%) scale(0)';
  nextBtn.style.display = 'none';
  hintEl.style.display = 'block';
  hintEl.textContent = 'TAP TO START';
  state = 'ready';
  resetSphere();
}

// --- Draw functions ---
function drawBackground() {
  const world = getWorld();
  const grad = ctx.createLinearGradient(0, bgOffsetY, 0, H + bgOffsetY);
  grad.addColorStop(0, world.bgTop);
  grad.addColorStop(1, world.bgBot);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function drawObstacles() {
  const lv = getLevel();
  const world = getWorld();
  ctx.strokeStyle = world.primary;
  ctx.lineWidth = 2;
  ctx.shadowColor = world.primary;
  ctx.shadowBlur = 8;
  for (const obs of lv.obstacles) {
    const ox = screenX(obs.x), oy = screenY(obs.y);
    const ow = obs.w * W, oh = obs.h * H;
    ctx.strokeRect(ox, oy, ow, oh);
  }
  ctx.shadowBlur = 0;
}

function drawGoal() {
  const lv = getLevel();
  const gx = screenX(lv.goalX), gy = screenY(lv.goalY);
  const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.004);
  ctx.strokeStyle = `rgba(0,255,255,${pulse})`;
  ctx.lineWidth = 2.5;
  ctx.shadowColor = '#00FFFF';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(gx, gy, lv.goalR, 0, Math.PI * 2);
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function drawTrail() {
  if (trail.length < 2) return;
  for (let i = 1; i < trail.length; i++) {
    const a = trail[i-1], b = trail[i];
    const color = lerpColor(getWorld().trailA, getWorld().trailB, b.t);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 3.5 + Math.random();
    ctx.lineCap = 'round';
    ctx.globalCompositeOperation = 'lighter';
    ctx.stroke();
    ctx.globalCompositeOperation = 'source-over';
  }
}

function drawScatter() {
  for (const dot of scatterDots) {
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, 1.5, 0, Math.PI*2);
    ctx.fillStyle = dot.color;
    ctx.globalAlpha = dot.alpha;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }
}

function drawSphere() {
  if (state === 'complete') return;
  // Glow
  const grad = ctx.createRadialGradient(sphere.x, sphere.y, 0, sphere.x, sphere.y, SPHERE_RADIUS*2.5);
  grad.addColorStop(0, 'rgba(255,255,255,0.9)');
  grad.addColorStop(0.3, 'rgba(180,220,255,0.5)');
  grad.addColorStop(1, 'rgba(0,180,255,0)');
  ctx.globalCompositeOperation = 'lighter';
  ctx.beginPath();
  ctx.arc(sphere.x, sphere.y, SPHERE_RADIUS*2.5, 0, Math.PI*2);
  ctx.fillStyle = grad;
  ctx.fill();
  // Core
  ctx.beginPath();
  ctx.arc(sphere.x, sphere.y, SPHERE_RADIUS, 0, Math.PI*2);
  ctx.fillStyle = '#ffffff';
  ctx.fill();
  ctx.globalCompositeOperation = 'source-over';
}

function drawParticles() {
  for (const p of particles) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius * p.life, 0, Math.PI*2);
    ctx.fillStyle = hexToRgba(p.color.replace('rgb(','').replace(')','').startsWith('r') ? '#00D4FF' : p.color, p.life * 0.8);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }
}

function drawMenu() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  // Title glow
  ctx.shadowColor = '#00D4FF';
  ctx.shadowBlur = 30;
  ctx.fillStyle = '#00D4FF';
  ctx.font = `bold ${W*0.18}px Impact, Arial Black`;
  ctx.textAlign = 'center';
  ctx.fillText('FREEFALL', W/2, H*0.42);
  ctx.shadowBlur = 0;
  // Subtitle
  ctx.font = `${W*0.035}px Arial`;
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.letterSpacing = '4px';
  ctx.fillText('TAP ANYWHERE TO PLAY', W/2, H*0.52);
  // Trail line
  ctx.beginPath();
  ctx.moveTo(W*0.2, H*0.56);
  ctx.lineTo(W*0.8, H*0.56);
  ctx.strokeStyle = 'rgba(0,212,255,0.4)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.textAlign = 'left';
}

// --- Main loop ---
let lastTime = 0;
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 16.67, 3);
  lastTime = ts;

  ctx.clearRect(0, 0, W, H);

  if (state === 'menu') {
    drawMenu();
    requestAnimationFrame(loop);
    return;
  }

  drawBackground();
  drawTrail();
  drawScatter();
  drawObstacles();
  drawGoal();
  drawSphere();
  drawParticles();

  // Update particles
  particles = particles.filter(p => {
    p.x += p.vx; p.y += p.vy;
    p.vy += gravityDir * 0.05;
    p.life -= p.decay;
    return p.life > 0;
  });

  if (state === 'playing') {
    // Physics
    sphere.vy += GRAVITY_MAG * gravityDir * dt;
    sphere.x += sphere.vx * dt;
    sphere.y += sphere.vy * dt;

    // Parallax
    bgOffsetY -= sphere.vy * 0.15 * dt;
    bgOffsetY = Math.max(-H*0.1, Math.min(H*0.1, bgOffsetY));

    // Trail
    const t = Math.min(distanceTravelled / 900, 1);
    trail.push({ x: sphere.x, y: sphere.y, t });
    if (trail.length > 1) {
      const prev = trail[trail.length-2];
      distanceTravelled += Math.sqrt((sphere.x-prev.x)**2 + (sphere.y-prev.y)**2);
    }

    // Scatter
    if (scatterDots.length < 1500) {
      const color = getTrailColor();
      for (let i = 0; i < 2; i++) {
        scatterDots.push({
          x: sphere.x + (Math.random()-0.5)*16,
          y: sphere.y + (Math.random()-0.5)*16,
          color,
          alpha: 0.15 + Math.random()*0.2
        });
      }
    }

    // Collision
    const hit = checkCollisions();
    if (hit === 'dead') {
      spawnDeathParticles(sphere.x, sphere.y);
      state = 'dead';
      deathTimer = 0;
    } else if (hit === 'complete') {
      const lv = getLevel();
      spawnGoalParticles(screenX(lv.goalX), screenY(lv.goalY));
      state = 'complete';
      completeTimer = 0;
      const word = getCompletionWord();
      wordEl.textContent = word;
      setTimeout(() => { wordEl.className = 'show'; }, 400);
      setTimeout(() => { nextBtn.style.display = 'block'; }, 800);
      hintEl.style.display = 'none';
    }
  }

  if (state === 'dead') {
    deathTimer += dt;
    if (deathTimer > 18) { // ~0.3s at 60fps
      trail = [];
      scatterDots = [];
      state = 'ready';
      resetSphere();
      hintEl.textContent = 'TAP TO RETRY';
      hintEl.style.display = 'block';
    }
  }

  requestAnimationFrame(loop);
}

// --- Input ---
function handleTap(e) {
  e.preventDefault();
  if (state === 'menu') {
    state = 'ready';
    resetSphere();
    hintEl.textContent = 'TAP TO START';
    hintEl.style.display = 'block';
    return;
  }
  if (state === 'ready') {
    state = 'playing';
    hintEl.style.display = 'none';
    return;
  }
  if (state === 'playing') {
    gravityDir *= -1;
    flipCount++;
    // Visual flip flash
    ctx.fillStyle = 'rgba(0,212,255,0.05)';
    ctx.fillRect(0, 0, W, H);
  }
  if (state === 'complete') return;
}

canvas.addEventListener('click', handleTap);
canvas.addEventListener('touchstart', handleTap, { passive: false });

requestAnimationFrame(loop);
</script>
</body>
</html>

FREEFALL — PRODUCTION BLUEPRINT
### The Complete Build Plan for a Premium iOS Gravity-Flip Puzzle Game
*Generated by Opus | Stage 3 | All clarifying questions answered*
-----
## HOW TO USE THIS DOCUMENT
This blueprint has four sections. Each serves a different person at a different moment:
1. **Engagement Science & Level Design Philosophy** — For Jamie. The psychology
research, translated into specific design rules for every level in the game. Read this to
understand *why* each design decision exists.
1. **Production Blueprint** — For Jamie + the build process. Architecture, build order, every
decision made and why.
1. **Design Assets** — For image generation. Midjourney-ready prompts for every visual
asset. Run these through image gen directly.
1. **Audio Brief** — For music production. Exact specs for every track and sound event.
1. **Codex Handoff** — For the coding agent. Machine-readable, no ambiguity, every screen
and element specified.
-----
## 1. ENGAGEMENT SCIENCE — Why Players Won’t Put This Down
This section translates peer-reviewed psychology research into specific, actionable design
rules for Freefall. Every rule maps to a real phenomenon. Nothing here is vibes — it’s all
mechanism.
### 1.1 The Flow Channel — Csikszentmihalyi’s Core Insight
Mihaly Csikszentmihalyi’s research (1990) identified that people enter a state of complete
absorption — “flow” — when the challenge of an activity is precisely matched to their skill
level. Too easy triggers boredom. Too hard triggers anxiety. Both cause the player to quit.
The narrow band between them is where players lose track of time.
**What this means for Freefall’s 40 levels:**
The difficulty curve is not a straight line. It’s a staircase with rest steps. Each world (10
levels) follows this internal pattern:
- **Levels 1-3 of each world:** Introduce the world’s new visual complexity. Difficulty is
*slightly below* the end of the previous world. This is the “rest step” — the player just
conquered something hard, and now they’re rewarded with a fresh environment that feels
manageable. Dopamine hit from novelty without anxiety from difficulty.- **Levels 4-7 of each world:** Steady climb. Each level adds one new spatial challenge
(narrower gap, new obstacle shape, longer path). The player’s skill is growing in sync with
the difficulty.
- **Level 8:** The “breather.” A level that feels easier than 7 — wider tolerances, a more
obvious solution path. This isn’t charity; it’s pacing. Research on the stair-step difficulty curve
(from serious game design literature) shows that a brief dip in difficulty after a climb
*increases* the player’s sense of competence and willingness to face the next spike.
- **Levels 9-10:** The world’s climax. Level 9 is the hardest spatial puzzle in the world. Level
10 is slightly easier than 9 but introduces a “performance” element — the level layout
rewards a beautiful trail. The player completes the world feeling like an artist, not just a
puzzle-solver.
**Specific design rule:** No level should take a first-time player more than ~90 seconds to
understand the *intended* solution path (even if execution takes multiple attempts). If the
player doesn’t know *what* to do, that’s anxiety. If they know what to do but can’t quite *do* it
yet, that’s flow.
### 1.2 The Dopamine Micro-Reward Loop
Research on dopamine systems in games (Schultz, 2015; Hull, Williams & Griffiths, 2013)
shows that the brain releases dopamine not just when receiving a reward, but during the
*anticipation* of reward. The anticipation phase actually produces more dopamine than the
reward itself.
**What this means for Freefall:**
Every level has a three-beat reward structure:
1. **The Preview Beat (anticipation):** Player sees the level layout during the tap-to-launch
ready state. They’re already planning their path. The music is playing. The goal ring is
pulsing gently. Dopamine begins building during this planning moment — the player
*anticipates* the satisfaction of solving it.
1. **The Execution Beat (variable reward):** The player is flipping gravity, threading through
gaps, watching their trail paint the screen. Each successful navigation past an obstacle is a
micro-reward. The trail itself is a continuous reward signal — you can *see* your success
accumulating in real time. This is Freefall’s secret weapon: most puzzle games only reward
at completion. Freefall rewards continuously through the trail.
1. **The Reveal Beat (completion reward):** Level complete. The trail art fills the screen.
CLEAN / FRESH / DOPE / NICE appears. The completion word is cosmetic but it functions
as a *variable reward* — the player doesn’t know which word they’ll get, and the variety
creates a micro-moment of surprise. This is the screenshot moment. This is the dopamine
peak.
**Specific design rule:** The completion word selection should feel *slightly* unpredictable.
Don’t tie it to a rigid formula the player can reverse-engineer. Weight it: CLEAN appears
~40% of the time (baseline good), FRESH ~25% (when the player completes in fewer flips
than expected), DOPE ~20% (when the trail art has high visual complexity / many
crossings), NICE ~15% (random / catch-all). The player will develop a *feeling* for whatearns each word without ever fully knowing — this is the variable ratio schedule that
Skinner’s research showed produces the strongest engagement.
### 1.3 The Zeigarnik Effect — Why “Just One More Level” Works
Soviet psychologist Bluma Zeigarnik discovered that people remember and feel compelled to
return to incomplete tasks. The brain creates a “tension loop” around unfinished work that
only resolves upon completion.
**What this means for Freefall:**
- **World progress is visible.** On the level select screen, the player sees all 10 levels —
completed ones show a thumbnail of their trail art, incomplete ones show a dim outline. The
incomplete slots create Zeigarnik tension. “I’ve done 7 of 10 — I need to finish this world.”
- **The locked world cards on the world select screen** serve double duty: they’re
progression gates AND Zeigarnik triggers. The player can *see* UNDERGROUND and
STATIC waiting. The lock icon isn’t just a gate — it’s an unfinished task.
- **Never show total progress as a percentage.** Percentages invite calculation (“I’m only
25% done, this will take forever”). Instead, show progress as *art completion* — how much
of the world’s visual canvas has been painted. The metaphor reinforces the identity.
### 1.4 The Generative Art Hook — Why This Game Is More Addictive Than Standard
Puzzles
Standard puzzle games give you a binary outcome: solved or not solved. Freefall gives you
a *unique creative artifact* every time you complete a level. This is psychologically powerful
for three reasons:
1. **Ownership effect (endowment effect):** Once the player has “created” a piece of trail art,
they value it disproportionately. It’s *theirs*. This creates attachment to the game itself.
1. **Variable outcome:** Even on the same level, two runs produce different art. The player
is not just solving a puzzle — they’re discovering what their solution *looks like*. This is an
additional layer of variable reward on top of the completion itself.
1. **Social currency:** A beautiful trail art screenshot has social value. It’s shareable
*because* it’s unique and because it’s beautiful. This is the TikTok / Instagram hook — but it
works because the underlying psychology (creation + ownership + beauty) is real.
**Specific design rule:** Level layouts should be designed so that the “optimal” solution path
(fewest flips) produces a visually interesting trail, but sub-optimal paths also produce
beautiful — sometimes *more* beautiful — art. The player should never feel punished for an
inefficient path. The art IS the reward, regardless of efficiency.
### 1.5 The Rhythm-Flow Connection — Why Music Makes the Mechanic More Addictive
Game design research on “microflow” shows that when player inputs align with a rhythmic
pattern, the flow state deepens significantly. The player’s taps begin to feel like part of the
music rather than separate from it.**What this means for Freefall:**
- The gravity flip is a tap. Taps are rhythmic by nature. When the music has a strong, steady
beat (which D&B / hip hop inherently does), the player’s flip timing will *unconsciously* sync
to the beat. This isn’t a rhythm game — we’re not scoring on beat timing — but the *felt
experience* is that the game and the music are one thing.
- Each world’s music BPM should roughly correlate to the intended pacing of that world’s
levels. World 1 (learning, relaxed) = slower BPM. World 4 (intense, precise) = faster BPM.
The music is teaching the player how fast to think.
- The gravity flip SFX should be designed to feel like a percussion hit that *belongs* in the
track. Not a separate game sound layered on top of music — an *instrument* in the mix.
**Specific design rule:** When designing levels, playtest them with the world’s music playing.
If the natural flip rhythm feels like it fights the beat, adjust the level layout. The level and the
music should feel like they were made for each other.
### 1.6 Non-Punishing Death — The Science of “Encouraging Failure”
Research consistently shows that harsh failure penalties increase anxiety and push players
out of the flow channel. But *no* consequence for failure removes tension entirely, causing
boredom. The sweet spot: failure is acknowledged, visually satisfying, and instantly
recoverable.
**What this means for Freefall:**
- Death = particle burst (satisfying to watch, not painful) → trail fades → instant restart
- No animation delay. No “retry?” dialog. No loading screen. The player should be back at
the ready state within 0.3 seconds of death. Speed of retry is directly correlated with
willingness to retry.
- The particle burst should feel *cool*, not punishing. The sphere shatters into neon
fragments that scatter. It should look good enough that dying doesn’t feel bad — it feels like
a visual moment.
- No death counter visible to the player. No “you died 47 times on this level” stat. Failure is
private and impermanent.
### 1.7 Summary: The Addiction Architecture
Putting it all together, here’s Freefall’s engagement loop in one cycle:
```
SEE the level layout (anticipation → dopamine builds)
↓
TAP to launch (commitment)
↓
FLIP through obstacles (continuous micro-rewards via trail)
↓
[IF DEATH] → cool particle burst → instant restart → SEE again
↓[IF COMPLETE] → trail art reveal → CLEAN/FRESH/DOPE/NICE (variable reward)
↓
SEE next level (Zeigarnik: "just one more")
↓
REPEAT
```
The music never stops through this loop. It carries across death, across retry, across level
transitions. The music is the thread that keeps the player in the flow state even when the
game state resets.
-----
## 2. PRODUCTION BLUEPRINT
### 2.1 Architecture Overview
Freefall is a single-target iOS app built entirely in SwiftUI + SpriteKit. There is no backend,
no networking, no accounts. All state lives on-device in UserDefaults (progress) and bundled
JSON (level data).
**Core architecture layers:**
- **Presentation Layer (SwiftUI):** All menus, navigation, world select, level select, settings,
level complete screen. SwiftUI owns the UI chrome.
- **Game Layer (SpriteKit):** The actual gameplay — physics, sphere, trail rendering,
obstacles, goal detection, death detection. SpriteKit owns everything inside the game
canvas.
- **Bridge Layer:** A shared `GameState` object (using @Observable) that both SwiftUI and
SpriteKit read/write. SwiftUI tells SpriteKit “load level 14.” SpriteKit tells SwiftUI “level
complete” or “player died.” This is the critical interface — keep it clean and minimal.
- **Data Layer:** Level definitions as bundled JSON. Player progress in UserDefaults. No
CoreData, no CloudKit, no SQLite at MVP.
**Why this architecture:** SwiftUI is excellent for menus and navigation but cannot render
real-time physics games. SpriteKit is excellent for physics games but terrible for UI. The
bridge pattern lets each framework do what it’s best at. The @Observable GameState object
is the single source of truth.
### 2.2 The Physics Model
The gravity flip mechanic needs to feel *exactly right* or the entire game fails. Here’s the
precise spec:
**Sphere properties:**
- Mass: Tunable constant (start at 1.0, adjust in playtesting)- Restitution (bounciness): 0.0 — the sphere does NOT bounce off surfaces. Hitting a wall =
death. This is a puzzle game, not a bouncy ball game.
- Friction: Low (0.1) — the sphere slides along surfaces it’s resting on before launch
- Linear damping: Very low (0.05) — momentum carries. The sphere doesn’t slow down
artificially in mid-air. This is what creates the sweeping arcs.
**Gravity flip:**
- Default gravity: (0, -9.8) — standard downward
- On tap: Gravity instantly becomes (0, +9.8) or (0, -9.8) — a toggle
- “Instantly” means within one physics frame. No easing, no transition. The snap is the feel.
- The sphere retains ALL horizontal velocity on flip. Only the vertical component reverses
direction (via gravity, not velocity injection). This means the sphere traces parabolic arcs —
wide, sweeping curves that produce beautiful trails.
- Haptic feedback on every flip: UIImpactFeedbackGenerator with .medium style. This is
non-negotiable. The flip must feel physical.
**Horizontal movement:**
- The sphere has an initial horizontal velocity applied at launch (direction determined by level
design — some levels launch left-to-right, some right-to-left, some with variable angle)
- No horizontal input from the player. Horizontal velocity is set at launch and modified only by
physics (wall collisions = death, so effectively it’s constant during flight)
- This is what makes it a puzzle: the player controls ONLY the vertical via gravity flips.
Horizontal momentum is a given. The puzzle is: *when* do I flip to thread through this
obstacle layout given my fixed horizontal drift?
**Death conditions:**
- Sphere contacts any obstacle physics body → death
- Sphere exits screen bounds (any edge) → death
- No health, no shields, no second chances
**Goal condition:**
- Sphere enters the goal ring’s trigger area → level complete
- Goal ring has a generous hitbox (1.5x visual radius). Completing a level should feel
forgiving, not pixel-perfect. The challenge is getting *to* the goal, not hitting it precisely.
### 2.3 The Paint Trail System — Technical Design
This is the most technically important system in the game and the most artistically important
feature. Get this wrong and the game has no identity.
**How the trail works:**
The trail is a series of textured quads rendered along the sphere’s path. Every physics
frame, the system:1. Records the sphere’s position
1. Calculates the direction vector from the previous position
1. Creates a short trail segment (a textured SKSpriteNode or SKShapeNode) at that position
1. Sets the segment’s colour based on the trail gradient (position in level → colour
interpolation)
1. Applies a slight random width variation (±15%) to create the spray-paint scatter effect
1. Adds subtle particle emitters at the trail edges for the “bleed” effect
**Trail colour system:**
- Each world has a primary trail gradient: two anchor colours that the trail interpolates
between as the sphere travels
- World 1 (THE BLOCK): Electric blue (#00D4FF) → Hot pink (#FF1493)
- World 2 (NEON YARD): Acid green (#39FF14) → Electric yellow (#FFE600)
- World 3 (UNDERGROUND): Deep orange (#FF6600) → Blood red (#CC0000)
- World 4 (STATIC): Violet (#8B00FF) → White (#FFFFFF)
**Trail persistence:**
- Trail segments persist for the entire level attempt. They do NOT fade.
- On death: all trail segments fade out over 0.3 seconds, then are removed. Level resets
clean.
- On level complete: trail stays on screen. This IS the art reveal. The camera may zoom out
slightly (or the game view may scale down) to show the full trail composition.
**Trail rendering performance:**
- Trail segments should be batched. Don’t create individual SKNodes for every frame — use
an SKShapeNode with an accumulating CGPath, or render to an offscreen texture at
intervals.
- Target: 60fps on iPhone 12 and above with full trail visible. If performance dips, reduce trail
segment frequency (every 2nd frame instead of every frame) — the visual difference is
negligible but the performance gain is significant.
**What makes the trail look like spray paint (not a clean vector line):**
- Width variation per segment (random ±15%)
- Edge particle emitters: tiny dot particles that scatter 5-10px from the trail edge, low opacity
(0.2-0.4), random lifetime (0.1-0.5s). These create the “overspray” effect.
- The trail has a subtle inner glow — the centre of the trail is brighter/whiter than the edges.
This is achieved with additive blending on the centre portion.
### 2.4 Level Data Format
Every level is defined in a JSON file bundled with the app. One JSON file per world (4 files
total). Each level definition contains:```
{
"worldId": 1,
"levelId": 3,
"launchPosition": { "x": 0.1, "y": 0.5 },
"launchVelocity": { "dx": 120, "dy": 0 },
"goalPosition": { "x": 0.85, "y": 0.3 },
"goalRadius": 30,
"initialGravityDown": true,
"obstacles": [
{
"type": "rect",
"x": 0.4, "y": 0.0,
"width": 0.05, "height": 0.35,
"style": "neon_outline"
}
]
}
```
All positions are normalized (0.0 to 1.0) relative to the game canvas. This makes iPad
adaptation automatic — the same level data scales to any screen aspect ratio.
Obstacle types: `rect`, `circle`, `polygon`, `line`. The obstacle `style` field determines visual
rendering (neon_outline, textured, pulsing, abstract) and is world-dependent.
### 2.5 Build Order
This is the sequence. Each step lists its dependencies explicitly. Do not reorder.
**Phase 1 — Core Engine (Week 1-2)**
|Step|Task |Depends On|Output |
|----|------------------------------------------|----------|-------------------------------------------|
|1 |SpriteKit game scene with sphere + gravity|Nothing |Sphere falls, flips on tap
|
|2 |Obstacle loading from JSON |Step 1 |Static obstacles render and have
physics |
|3 |Collision detection (death + goal) |Steps 1, 2|Player dies on wall hit, completes on
goal |
|4 |Paint trail system (basic) |Step 1 |Trail renders behind sphere with gradient |
|5 |Trail spray-paint effects |Step 4 |Width variation, edge particles, inner glow|
|6 |Level restart on death |Step 3 |Particle burst, trail fade, instant reset |
|7 |Level complete sequence |Steps 3, 4|Trail art reveal, completion word
display |**At end of Phase 1:** You can play a level. Sphere moves, trail paints, obstacles kill, goal
completes. This is the vertical slice. If this doesn’t feel good, nothing else matters. STOP and
iterate on feel before moving to Phase 2.
**Phase 2 — Game Structure (Week 2-3)**
|Step|Task |Depends On|Output |
|----|-----------------------------|----------|----------------------------------------------------------------|
|8 |GameState @Observable model |Nothing |Progress tracking, level/world state
|
|9 |Level select screen (SwiftUI)|Step 8 |Grid of 10 levels per world, lock states
|
|10 |World select screen (SwiftUI)|Steps 8, 9|4 world cards, lock states
|
|11 |SwiftUI ↔ SpriteKit bridge |Steps 7, 8|Navigate from level select → game → back
|
|12 |Level progression logic |Steps 3, 8|Complete level → unlock next, complete world →
unlock next world|
|13 |Main menu screen |Step 10 |FREEFALL title, PLAY button, settings icon
|
**Phase 3 — Audio + Polish (Week 3-5)**
|Step|Task |Depends On|Output |
|----|----------------------------|----------|-------------------------------------------------|
|14 |Audio engine setup |Nothing |AVAudioPlayer for music, SKAction for SFX |
|15 |Music integration (4 tracks)|Step 14 |World-specific music, crossfade on transition |
|16 |SFX integration |Step 14 |Flip sound, death sound, goal sound, UI taps |
|17 |Haptic feedback system |Step 1 |Flip haptic, death haptic, goal haptic |
|18 |Settings screen |Step 13 |Music toggle, SFX toggle, haptics toggle |
|19 |Level complete screen polish|Step 7 |CLEAN/FRESH/DOPE/NICE with spray-paint
typography|
|20 |Particle effects polish |Steps 5, 6|Death burst, goal celebration, ambient particles |
**Phase 4 — Content + Ship (Week 5-7)**
|Step|Task |Depends On |Output |
|----|---------------------------------|---------------------|--------------------------------------------------------------
-|
|21 |Design all 40 levels |Steps 1-7 |JSON level data for all 4 worlds
|
|22 |Playtest difficulty curve |Step 21 |Adjust obstacles per engagement science
rules |
|23 |World visual themes |Steps 2, 5 |Obstacle styles per world (outline →
texture → glow → abstract)|
|24 |iPad adaptive layout |All screens |Test on iPad, adjust safe areas and
scaling ||25 |App icon + App Store assets |Design assets section|1024x1024 icon, screenshots,
preview video |
|26 |Final QA pass |Everything |Crash testing, edge cases, performance
profiling |
|27 |TestFlight → App Store submission|Step 26 |Ship it
|
### 2.6 Key Architecture Decisions
**Why UserDefaults and not CoreData for progress:**
We’re storing: which levels are complete (a Set of level IDs) and which worlds are unlocked
(a Set of world IDs). That’s two small arrays. UserDefaults handles this trivially. CoreData is
overkill and adds migration complexity for zero benefit.
**Why bundled JSON and not a level editor:**
40 handcrafted levels. Not procedural. JSON is human-readable, version-controllable, and
trivial to parse in Swift. A visual level editor would be nice but is scope-creep — edit the
JSON directly, test in-game, iterate.
**Why AVAudioPlayer for music and not SKAudioNode:**
SKAudioNode is tied to the SpriteKit scene lifecycle. When we transition between SwiftUI
screens (menus) and SpriteKit (gameplay), SKAudioNode would stop. AVAudioPlayer is
independent — the music plays across the entire app, uninterrupted by navigation. The
music never stops. This is critical for the flow state.
**Why no onboarding tutorial screen:**
Level 1 of World 1 IS the tutorial. Wide open space, single obstacle, goal directly above. The
player taps, the sphere flips, they get it. Inks does this. Alto’s does this. A tutorial screen is a
barrier between the player and the flow state. Remove it.
-----
## 3. DESIGN ASSETS — Image Generation Prompts
Every prompt below is written for Midjourney v6+ or DALL-E 3. Run them as-is. Each prompt
includes a spec block with technical requirements.
### 3.1 App Icon
**Prompt:**
```
Mobile app icon, 1024x1024, rounded square. Pure black background. A small glowing white
sphere with intense neon blue-cyan aura, positioned slightly above centre. A single
sweeping spray-paint trail curves behind it — gradient from electric blue to hot pink, with
visible paint scatter and bleed at edges. No text, no other elements. The sphere should look
like a comet cutting through darkness. Minimal, bold, street art energy. The trail should have
enough visual mass to read at 60px thumbnail size. --ar 1:1 --s 250```
**Spec:**
- 1024×1024 rounded square (Apple auto-rounds corners)
- Must read clearly at 60px (iPhone home screen), 40px (Spotlight), and 29px (Settings)
- No text on the icon — “FREEFALL” is the app name, not on the icon
- Do NOT include any letters, words, or typography in the icon
- Generate 4 variants, pick the one with clearest silhouette at small sizes
### 3.2 Splash / Launch Screen
**Prompt:**
```
Mobile game launch screen, portrait orientation, 1290x2796. Pure black background. The
word "FREEFALL" in massive bold condensed sans-serif typography, centred, spray-paint
textured — slightly rough edges, not perfectly crisp. Glowing cyan/blue colour with subtle
outer glow. Below the title: a single thin neon line, like a paint streak, horizontal across the
screen. Nothing else. Minimal. Confident. The vibe of a hip hop single cover. --ar 9:19.5 --s
200
```
**Spec:**
- 1290×2796 (iPhone 15 Pro Max native, will be scaled for other devices)
- The actual launch screen in Xcode will be a simple SwiftUI view: black background +
“FREEFALL” text + neon line. This prompt is for the *vibe reference* — the coded version
recreates it programmatically.
- Generate 2 variants
### 3.3 World Backgrounds
Each world has a distinct background texture/atmosphere. These are NOT solid black —
they’re black with subtle ambient texture that sets the mood. Rendered behind the gameplay.
**World 1 — THE BLOCK**
```
Dark abstract background texture for a mobile game. Portrait orientation. Near-black
background (#0A0A0A) with very subtle blue-tinted spray paint mist in the lower corners.
Faint geometric grid lines in dark blue (#0D1B2A), barely visible. Like staring at a dark brick
wall under a single blue streetlight. No objects, no characters, no text. Just atmosphere.
Ambient, urban, minimal. --ar 9:19.5 --s 150
```
**Colour palette:** Primary #00D4FF (electric blue), Secondary #1A1A2E (deep navy),
Accent #FF1493 (hot pink)**World 2 — NEON YARD**
```
Dark abstract background texture for a mobile game. Portrait orientation. Near-black
background with a toxic green chemical haze — very subtle, concentrated in the
mid-section. Faint cracked pavement texture, like looking down at a dark parking lot with
neon green light spilling from off-screen. No objects, no characters, no text. Grungy,
industrial, alive. --ar 9:19.5 --s 150
```
**Colour palette:** Primary #39FF14 (acid green), Secondary #1A1A0A (dark olive), Accent
#FFE600 (electric yellow)
**World 3 — UNDERGROUND**
```
Dark abstract background texture for a mobile game. Portrait orientation. Near-black
background with deep orange/amber glow emanating from the bottom edge — like firelight in
a tunnel. Faint rust textures and industrial grain. Like being underground in a
decommissioned subway station lit by a single sodium lamp. No objects, no characters, no
text. Warm, dangerous, raw. --ar 9:19.5 --s 150
```
**Colour palette:** Primary #FF6600 (deep orange), Secondary #1A0A00 (near-black
brown), Accent #CC0000 (blood red)
**World 4 — STATIC**
```
Dark abstract background texture for a mobile game. Portrait orientation. Near-black
background with digital noise / CRT static interference patterns — very subtle, flickering
quality. Faint violet and white pixel artifacts, like a screen glitching. The feeling of staring into
a broken television at 3am. No objects, no characters, no text. Unsettling, electric, abstract.
--ar 9:19.5 --s 150
```
**Colour palette:** Primary #8B00FF (violet), Secondary #0A000A (near-black purple),
Accent #FFFFFF (white)
### 3.4 Player Shape (Sphere)
**Prompt:**
```
Game asset on pure black background. A single glowing white sphere, small (like a marble).
Intense white core with soft neon aura that bleeds outward — the aura transitions from whiteat centre to cyan/blue at edges. Like a miniature star or a welding arc. Subtle lens flare.
Completely isolated, no other elements. Asset sheet style, clean cutout. --ar 1:1 --s 200
```
**Spec:**
- In-game the sphere is approximately 24-32pt diameter on iPhone
- The “aura” extends another 8-12pt beyond the core
- In SpriteKit: the core is an SKSpriteNode with the texture; the aura is an SKEffectNode with
a Gaussian blur, or a simple pre-rendered texture with additive blending
- Generate the sphere at 128×128, display at 32×32 with the texture handling the glow.
Alternatively, build it entirely in code: a white circle with an SKEffectNode glow filter.
### 3.5 Obstacles Per World
**World 1 — Pure neon outlines:**
```
Game asset sheet on pure black background. Geometric obstacle shapes for a mobile
game: rectangles, L-shapes, angled walls. Rendered as OUTLINE ONLY — no fill, just
glowing neon lines. Electric blue/cyan colour (#00D4FF) with subtle outer glow. Line weight
approximately 2-3px. Clean, precise, like Tron lightcycles. 4-6 different shapes arranged on
the sheet. --ar 16:9 --s 200
```
**World 2 — Outlines + texture fill:**
```
Game asset sheet on pure black background. Geometric obstacle shapes: rectangles,
L-shapes, angled walls. Outlines are glowing acid green (#39FF14). The interior fill is a very
dark concrete/asphalt texture — barely visible but tactile. Like neon tape stuck to a dark
pavement surface. 4-6 shapes arranged on the sheet. --ar 16:9 --s 200
```
**World 3 — Glowing/pulsing obstacles:**
```
Game asset sheet on pure black background. Geometric obstacle shapes with an inner glow
effect. Deep orange (#FF6600) outlines with the shapes themselves emitting a subtle warm
light from within — like hot metal. Slight ember particle effects around edges. The shapes
feel dangerous and alive. 4-6 shapes arranged on the sheet. --ar 16:9 --s 200
```
**World 4 — Abstract layered neon:**
```
Game asset sheet on pure black background. Abstract geometric obstacle shapes —
complex, layered, almost architectural. Multiple overlapping neon outlines in violet(#8B00FF) and white (#FFFFFF). Glitch artifacts at the edges. The shapes look like they
could be decoded or like fragments of a larger pattern. Visually the most intense and
complex. 4-6 shapes arranged on the sheet. --ar 16:9 --s 200
```
**Important note on obstacle assets:** In the actual build, obstacles are rendered
programmatically in SpriteKit (SKShapeNode with styled paths), not as textures. These
image gen prompts are for *style reference* — they define what the code should replicate.
The developer uses these images as the visual target, then builds the obstacles in code.
### 3.6 Goal Ring
**Prompt:**
```
Game asset on pure black background. A glowing ring, circular, like a portal or a basketball
hoop made of light. Bright cyan (#00FFFF) neon outline with soft outer glow and subtle inner
pulsing light. Clean, minimal. The centre of the ring is transparent/black — just the ring itself.
Like a neon sign in the shape of a circle, floating in darkness. --ar 1:1 --s 200
```
**Spec:**
- In-game: approximately 48-64pt diameter
- The ring pulses gently (0.8s cycle, opacity oscillates between 0.7 and 1.0)
- On goal hit: the ring flashes bright white, emits a brief burst of cyan particles outward, then
fades. This is the celebration moment.
### 3.7 UI Style Reference
**Main Menu:**
```
Mobile game main menu screen, portrait orientation. Pure black background. "FREEFALL" in
massive bold condensed sans-serif typography — spray-paint textured, slightly rough edges.
Glowing cyan colour. Below: a single large "PLAY" button, just the word "PLAY" in the same
spray-paint style but smaller, with a subtle neon glow outline around it. Bottom corners: a
small settings gear icon (outline only, cyan) on the left, a small speaker icon (outline only,
cyan) on the right. A faint, ghostly sphere drifts slowly behind the title leaving a barely visible
trail — ambient, not distracting. Ultra minimal. Dark. Confident. --ar 9:19.5 --s 200
```
**Level Select:**
```
Mobile game level select screen, portrait orientation. Pure black background. Title "THE
BLOCK" at the top in bold condensed spray-paint typography, electric blue. Below: a grid of
10 level cells (2 columns × 5 rows). Completed levels show a tiny thumbnail of their trail art(colourful abstract scribbles). Locked levels show a dim neon outline of the number. The
currently unlocked (next) level has a brighter, pulsing outline. Clean grid layout, generous
spacing. Urban, minimal. --ar 9:19.5 --s 200
```
### 3.8 Level Complete Screen — “CLEAN” Reference
Your ChatGPT mockup already nailed this. For Midjourney generation of the word variants:
```
Bold typography on black background. The word "CLEAN" in massive condensed sans-serif
letters. Spray-paint texture — visible paint scatter, rough edges, slightly uneven baseline.
Gradient colour from cyan through white to pink. Like spray-painted on a wall with a stencil
but imperfectly. No other elements. Just the word. --ar 3:4 --s 200
```
Generate variants replacing “CLEAN” with “FRESH”, “DOPE”, “NICE”. Same style, same
treatment. These will be overlaid on the trail art at level complete.
-----
## 4. AUDIO BRIEF
### 4.1 Overall Sonic Identity
Freefall sounds like a late-night drive through a city with the windows down. The music is
head-nodding, beat-heavy, and cool — not aggressive, not chill-out, not EDM. It sits in the
space between relaxation and energy that D&B, jungle, and classic hip hop share.
**Reference artists for the overall *feeling* (not to copy, but to triangulate the vibe):**
- DJ Shadow — *Endtroducing* (the dark, sample-heavy, headphone atmosphere)
- LTJ Bukem — *Logical Progression* (liquid drum and bass, beautiful but still has weight)
- J Dilla — *Donuts* (the head-nod, the imperfection, the warmth in the beats)
- Burial — *Untrue* (dark, urban, textured, emotional but never soft)
- Roni Size — *New Forms* (jungle with groove, not chaos)
The through-line: every reference here is music that sounds like a city at night. Dark but not
depressing. Heavy but not harsh. Cool in the way that doesn’t try.
### 4.2 Music Per World
**World 1 — THE BLOCK**
- **Sub-genre:** Boom bap / old school hip hop instrumental
- **BPM:** 85-95
- **Key instruments:** Dusty vinyl-sampled drums, deep sub bass (808-style), muted piano
chords, vinyl crackle texture, occasional brass stab- **Mood:** Confident, head-nodding, welcoming. This is “welcome to the neighbourhood.”
The player is learning the mechanic — the music should feel comfortable and inviting, not
challenging.
- **Reference track:** DJ Premier — “Unbelievable” instrumental / Pete Rock — “They
Reminisce Over You” (the beat, not the vocals)
- **Evolution across 10 levels:** The track plays continuously. Layers build subtly as the
player progresses — level 1 might have just the drums and bass, by level 5 the piano comes
in, by level 8 there’s a horn stab. This should feel organic, not like obvious “the music
changed because I progressed.”
**World 2 — NEON YARD**
- **Sub-genre:** Liquid drum and bass
- **BPM:** 170-174
- **Key instruments:** Fast crisp breakbeats, rolling bass, ethereal female vocal sample
(wordless, just texture), warm synth pads, subtle reversed cymbal swells
- **Mood:** Flowing, beautiful, energetic but smooth. The tempo is fast but the feel is
graceful — like the sphere’s sweeping arcs. The player is competent now; the music
celebrates their skill.
- **Reference track:** LTJ Bukem — “Horizons” / Calibre — “Even If”
- **Evolution:** Bass weight increases through levels. Early levels: lighter, pad-heavy. Late
levels: the breakbeats become more prominent, the bass deepens. Level 10 should feel like
a peak.
**World 3 — UNDERGROUND**
- **Sub-genre:** Dark jungle / breakbeat
- **BPM:** 160-168
- **Key instruments:** Chopped amen breaks, deep reese bass, dark vocal chops (gritty,
processed), metallic percussion hits, sub drops
- **Mood:** Intense, dark, focused. The difficulty is real now. The music reflects the stakes
without causing anxiety — it should make the player feel *locked in*, not stressed. Urban.
Raw.
- **Reference track:** Roni Size — “Brown Paper Bag” / Goldie — “Inner City Life” (the
energy, the darkness)
- **Evolution:** More chaotic as levels progress. Early: steady, driving. Late: the breaks get
more chopped, the bass more aggressive. The music is pushing the player’s intensity to
match the level difficulty.
**World 4 — STATIC**
- **Sub-genre:** Dark/minimal dubstep meets abstract hip hop
- **BPM:** 140
- **Key instruments:** Deep wobble bass (not brostep — think early Burial/Skream), glitchy
digital textures, static/white noise sweeps, sparse trap hi-hats, sub bass that you feel more
than hear- **Mood:** Abstract, alien, final. This world is the climax. The music should feel like arriving
somewhere new and unknown. Sparse, not wall-of-sound. Space between the beats is as
important as the beats themselves.
- **Reference track:** Burial — “Archangel” / Skream — “Midnight Request Line”
- **Evolution:** Paradoxical — the music gets *sparser* as levels progress, not fuller. By
level 40, the player is navigating near-silence with just sub-bass pulses and glitch textures.
The final level should feel almost meditative despite being the hardest. The contrast between
music simplicity and gameplay complexity is the artistic statement.
### 4.3 SFX Spec — Every Sound Event
**Gravity flip:**
The most important sound in the game. Heard thousands of times.
- A short, percussive transient — like a finger snap mixed with a subtle bass drop
- Duration: 50-80ms (VERY short)
- Frequency content: a bright click in the 2-4kHz range (for clarity) layered with a sub-bass
thump in the 40-60Hz range (for weight)
- Should feel like a drum hit. Specifically like a punchy closed hi-hat with a sub-bass kick
underneath.
- Must not fatigue the ear after 500 repetitions. No harshness, no sibilance.
- Must feel like it belongs in whatever music track is playing — it should sound like a
percussion instrument, not a “game sound effect.”
**Goal reached:**
Earned, satisfying, brief.
- A bright tonal hit — like a bell or chime, but with a vinyl-warm quality (not sterile digital)
- Duration: 300-500ms with natural decay
- Pitched: a clear musical note (suggest C5 or G4 — consonant, uplifting)
- Layered with a subtle bass swell underneath (200ms, sub-bass, felt not heard)
- Follow with the completion word sound (see below)
**Level complete (CLEAN/FRESH/DOPE/NICE appearing):**
- A spray-paint hiss — literally the sound of a spray can being used. Short burst, 200-300ms.
- Layered with a bass drop (80-100Hz, 500ms)
- This should feel like the word is being sprayed onto the screen. The SFX IS the visual.
**Player death:**
Not punishing. Gentle. “Try again” energy.
- A soft, low-pitched “pff” — like glass dust settling. Not a crash. Not an explosion.
- Duration: 200-300ms
- Mostly sub-bass content with a gentle high-frequency scatter (matching the visual particle
burst)
- Think: the sound of dropping something soft into powder. Muted, textural.- Do NOT use: buzzers, alarms, sad tones, descending pitches, or anything
Pavlovian-negative
**Menu / UI taps:**
- Tiny percussive clicks. Think: fingertip on a matte surface.
- Duration: 20-30ms
- Dry, no reverb. Clean.
- Two variants (to avoid mechanical repetition): same character, slight pitch shift between
them.
**World transition (entering a new world):**
- A 1-2 second transitional sound: the current world’s music element fading out with reverb
while the new world’s signature sound fades in
- Think: a DJ crossfade between two records. One track’s reverb tail overlapping the new
track’s first beat.
- This sound bridges the SwiftUI world select screen to the SpriteKit gameplay. It tells the
player “you’re entering a new space.”
**Trail sound (optional but recommended):**
- A very quiet, continuous tone that shifts pitch based on the sphere’s velocity
- Think: a theremin played very softly, or wind through a tunnel
- This is almost subliminal — the player might not consciously hear it, but removing it would
feel like something’s missing
- Volume: -20dB below music. It’s felt, not heard.
- Pitch maps to sphere speed: slow = low, fast = high. This gives the player an audio cue for
their momentum without them needing to look at the sphere.
### 4.4 Production Recommendations
**For music tracks (priority order):**
1. **Suno / Udio (MVP — fast and cheap):** Generate 2-3 candidates per world. Prompt with
the sub-genre, BPM, instruments, and mood described above. Use the reference track
names in the prompt. Select the best, edit for length (each track should loop seamlessly at
2-3 minutes). Cost: $0. Time: 1-2 days.
1. **Commission a producer (post-launch upgrade):** Find a D&B / hip hop producer on
Fiverr or SoundBetter. Budget: £200-500 per track (£800-2000 for all four). Give them this
exact audio brief. Time: 2-4 weeks. This replaces the AI tracks with human-produced music
that will be significantly better — especially for jungle and D&B where the breakbeat
complexity benefits from a human ear.
1. **Royalty-free library (backup):** Artlist or Epidemic Sound have D&B and hip hop
instrumentals. Monthly subscription ~£15. Risk: other apps may use the same tracks. Only
use this if Suno output is unusable and you can’t wait for commission.
**For SFX:**1. **Freesound.org (free):** Search for individual elements (spray can hiss, finger snap,
glass dust) and layer them in GarageBand or Audacity.
1. **BFXR / Sfxr (free):** For the gravity flip and UI tap sounds. These tools generate
retro-style sound effects that can be post-processed to feel more organic.
1. **Custom recording:** Record a real spray can for the level complete sound. Record a
finger snap for the flip. Layer and process. This takes 30 minutes and produces the most
authentic results.
**Audio integration in SpriteKit:**
- Music: Use `AVAudioPlayer` with `numberOfLoops = -1` (infinite loop). Crossfade between
tracks on world transition using a 1-second volume ramp.
- SFX: Use `SKAction.playSoundFileNamed()` for simple one-shot sounds (flip, death, UI
taps). For the goal hit + level complete sequence, use `AVAudioPlayer` with precise timing
control.
- Do NOT use `SKAudioNode` — it’s tied to the scene lifecycle and breaks on scene
transitions.
- Audio session: Configure `AVAudioSession.sharedInstance()` with `.ambient` category so
Freefall’s music ducks/mixes with the user’s own music if they have something playing.
Alternatively, use `.soloAmbient` if you want Freefall’s music to take over. Decision:
`.soloAmbient` — the music is too important to compete with Spotify.
-----
## 5. CODEX HANDOFF — Machine-Readable Specification
This section is written for an AI coding agent. Every instruction is explicit. No ambiguity.
### 5.1 Screen Inventory
|#|Screen Name |Purpose |Navigate TO From
|Navigate FROM To |Nav Type |
|-|-----------------|---------------------------------------------------------|---------------------------|-----------------
--------------------------------------------------------------|-------------------------|
|1|MainMenuView |Entry point. Title + play button. |App launch
|WorldSelectView (tap PLAY), SettingsView (tap gear) |Root |
|2|WorldSelectView |Choose which world to play. |MainMenuView (tap
PLAY) |LevelSelectView (tap unlocked world), MainMenuView (tap back) |Push
|
|3|LevelSelectView |Choose which level in a world. |WorldSelectView (tap
world)|GameView (tap unlocked level), WorldSelectView (tap back) |Push
|
|4|GameView |The actual gameplay. SpriteKit scene embedded in
SwiftUI.|LevelSelectView (tap level)|LevelCompleteView (on goal), LevelSelectView (tap
pause → quit) |Full screen cover ||5|LevelCompleteView|Shows trail art + completion word. |GameView (on goal
reached) |GameView with next level (tap NEXT LEVEL), LevelSelectView (tap back to
levels)|Modal overlay on GameView|
|6|SettingsView |Music / SFX / haptics toggles. |MainMenuView (tap gear)
|MainMenuView (tap back / dismiss) |Sheet |
### 5.2 Per-Screen UI Specification
#### Screen 1: MainMenuView
```
ROOT VIEW
├── Background: Color.black, ignoresSafeArea
├── VStack (centre aligned, spacing: 0)
│ ├── Spacer (flex)
│ ├── Text "FREEFALL"
│ │ ├── Font: custom heavy/black condensed, 64pt
│ │ ├── Colour: #00D4FF (cyan)
│ │ ├── Shadow: cyan glow, radius 20, opacity 0.4
│ │ └── Slight spray-paint texture overlay (optional — can be plain at MVP)
│ ├── Spacer (40pt)
│ ├── Button "PLAY"
│ │ ├── Font: custom heavy condensed, 28pt
│ │ ├── Colour: #00D4FF
│ │ ├── Border: 1pt cyan outline, corner radius 8
│ │ ├── Padding: 16pt horizontal, 12pt vertical
│ │ ├── Tap: navigate to WorldSelectView
│ │ └── Haptic: .light on tap
│ ├── Spacer (flex)
│ └── HStack (bottom, full width, padding horizontal 24)
│ ├── Button (gear icon — SF Symbol "gearshape")
│ │ ├── Colour: #00D4FF, opacity 0.6
│ │ ├── Size: 24pt
│ │ └── Tap: present SettingsView as sheet
│ ├── Spacer
│ └── Button (speaker icon — SF Symbol "speaker.wave.2" / "speaker.slash")
│ ├── Colour: #00D4FF, opacity 0.6
│ ├── Size: 24pt
│ └── Tap: toggle music on/off immediately
└── End
```
States: Only one state — always shows title + play. No loading, no empty, no error.
#### Screen 2: WorldSelectView
```
ROOT VIEW├── Background: Color.black, ignoresSafeArea
├── VStack (spacing: 16, padding: 24)
│ ├── Back button (top left, SF Symbol "chevron.left", cyan, tap → pop to MainMenuView)
│ ├── Spacer (20pt)
│ ├── ForEach world in [1, 2, 3, 4]:
│ │ └── WorldCard
│ │ ├── Height: ~120pt
│ │ ├── Full width (minus padding)
│ │ ├── Corner radius: 12
│ │ ├── Border: 2pt, world primary colour
│ │ ├── Background: world background image (subtle texture) at 10% opacity
│ │ ├── Content:
│ │ │ ├── Text: world name (THE BLOCK / NEON YARD / UNDERGROUND /
STATIC)
│ │ │ │ ├── Font: custom heavy condensed, 28pt
│ │ │ │ └── Colour: world primary colour
│ │ │ └── IF locked: lock icon (SF Symbol "lock.fill", white, opacity 0.5) aligned right
│ │ ├── IF unlocked: tap → navigate to LevelSelectView for this world
│ │ ├── IF locked: tap → do nothing (no alert, no popup, no "complete previous world"
message — the lock icon is enough)
│ │ └── IF locked: entire card opacity 0.4 (visually dimmed)
│ └── Spacer (flex)
└── End
```
World unlock state: World 1 always unlocked. World N+1 unlocks when all 10 levels of World
N are complete. Read from GameState.
#### Screen 3: LevelSelectView
```
ROOT VIEW
├── Background: Color.black, ignoresSafeArea
├── VStack
│ ├── HStack (top bar)
│ │ ├── Back button (chevron.left, world primary colour)
│ │ ├── Spacer
│ │ └── Text: world name, world primary colour, 22pt heavy condensed
│ ├── Spacer (20pt)
│ ├── LazyVGrid (columns: 2, spacing: 16, padding horizontal: 24)
│ │ └── ForEach level in 1...10:
│ │ └── LevelCell
│ │ ├── Aspect ratio: 1:1 (square)
│ │ ├── Corner radius: 8
│ │ ├── IF completed:
│ │ │ ├── Background: trail art thumbnail (stored as image data in UserDefaults —
OR — regenerated from saved path points)
│ │ │ ├── Overlay: level number (bottom left, 14pt, white, slight shadow)│ │ │ └── Tap → load this level in GameView
│ │ ├── IF unlocked (next to play):
│ │ │ ├── Background: black
│ │ │ ├── Border: 2pt, world primary colour, pulsing opacity animation (0.5 → 1.0,
1.5s loop)
│ │ │ ├── Text: level number, centre, world primary colour, 24pt
│ │ │ └── Tap → load this level in GameView
│ │ ├── IF locked:
│ │ │ ├── Background: black
│ │ │ ├── Border: 1pt, white, opacity 0.15
│ │ │ ├── Text: level number, centre, white, opacity 0.2, 20pt
│ │ │ └── Tap → do nothing
│ └── Spacer (flex)
└── End
```
Level unlock state: Level 1 of each world is always unlocked once the world is unlocked.
Level N+1 unlocks when level N is complete.
Trail art thumbnails: At MVP, don’t store trail art images. It adds significant storage
complexity. Instead, completed levels show a small coloured checkmark or filled circle in the
world’s primary colour. Trail art thumbnails can be added post-launch.
#### Screen 4: GameView
```
ROOT VIEW (full screen, no safe area insets)
├── SpriteKitView (fills entire screen)
│ └── GameScene (SKScene)
│ ├── Background: world background image node, full screen
│ ├── Obstacles: loaded from level JSON, positioned, physics bodies attached
│ ├── Goal ring: positioned from JSON, pulsing animation
│ ├── Player sphere: positioned at launch point
│ ├── Trail system: rendering layer behind sphere, above background
│ ├── HUD (SpriteKit overlay, not SwiftUI):
│ │ ├── Level number: top left, 16pt, white, opacity 0.5
│ │ └── Pause button: top right, SF Symbol "pause.circle", white, opacity 0.5
│ │ └── Tap → pause game, show pause overlay
│ ├── STATE: Ready
│ │ ├── Sphere at launch position, stationary
│ │ ├── "TAP TO START" text, centre bottom, white, opacity 0.3, 14pt
│ │ ├── Tap anywhere (except pause) → STATE: Playing
│ │ └── On transition to Playing: apply launch velocity to sphere, start trail recording
│ ├── STATE: Playing
│ │ ├── Sphere moving under gravity + momentum
│ │ ├── Trail rendering active
│ │ ├── Tap anywhere (except pause) → flip gravity
│ │ ├── Sphere contacts obstacle → STATE: Dead│ │ ├── Sphere exits screen bounds → STATE: Dead
│ │ └── Sphere enters goal trigger → STATE: Complete
│ ├── STATE: Dead
│ │ ├── Sphere replaced with particle burst (neon fragments, 0.3s)
│ │ ├── Trail fades out (0.3s)
│ │ ├── After 0.3s → automatically transition to STATE: Ready (same level)
│ │ └── No "retry" button. No dialog. Instant.
│ ├── STATE: Complete
│ │ ├── Goal ring flash animation (white, 0.2s)
│ │ ├── Goal celebration particles (cyan burst outward, 0.5s)
│ │ ├── Sphere fades out (0.3s)
│ │ ├── Trail remains visible
│ │ ├── After 0.8s → notify SwiftUI via GameState to present LevelCompleteView
│ │ └── Update GameState: mark level as complete, unlock next level
│ └── STATE: Paused
│ ├── Pause physics
│ ├── Dim game scene (overlay black at 50% opacity)
│ ├── Show: "RESUME" button (centre), "QUIT" button (below)
│ ├── RESUME → unpause physics, remove overlay
│ └── QUIT → dismiss GameView, return to LevelSelectView
└── End
```
#### Screen 5: LevelCompleteView
```
MODAL OVERLAY on GameView
├── Background: transparent (trail art visible behind)
├── VStack (centre aligned)
│ ├── Spacer (flex)
│ ├── Text: completion word (CLEAN / FRESH / DOPE / NICE)
│ │ ├── Font: custom heavy condensed, 56pt
│ │ ├── Colour: white with world-primary-colour gradient
│ │ ├── Spray-paint texture overlay
│ │ ├── Entrance animation: scale from 0.5 → 1.0, opacity 0 → 1, spring easing, 0.4s
│ │ └── SFX: spray-can hiss + bass drop on appearance
│ ├── Spacer (flex)
│ └── HStack (bottom, padding 24)
│ ├── Button "LEVELS" (left aligned)
│ │ ├── Font: 14pt, white, opacity 0.5
│ │ └── Tap → dismiss GameView, return to LevelSelectView
│ ├── Spacer
│ └── Button "NEXT LEVEL →" (right aligned)
│ ├── Font: 16pt heavy, world primary colour
│ ├── Border: 1pt, world primary colour, corner radius 6
│ ├── Tap → dismiss this overlay, load next level in GameView (STATE: Ready)
│ ├── IF this was level 10 of a world:
│ │ ├── Button text changes to "NEXT WORLD →"│ │ └── Tap → dismiss GameView, return to WorldSelectView (next world now
unlocked)
│ └── IF this was level 40 (final level):
│ ├── Button text changes to "FIN"
│ └── Tap → return to MainMenuView (maybe with a special animation —
post-MVP)
└── End
```
Completion word selection logic:
- Count total gravity flips during the level attempt
- If flips ≤ expected minimum (defined in level JSON as `parFlips`): “FRESH” (25% of the
time) or “CLEAN” (75%)
- If trail has >5 self-crossings (path crossed itself): “DOPE” (60%) or “CLEAN” (40%)
- Default / all other cases: weighted random — CLEAN 40%, FRESH 25%, DOPE 20%,
NICE 15%
- Never show the same word twice in a row
#### Screen 6: SettingsView
```
SHEET (presented from MainMenuView)
├── Background: Color.black
├── VStack (padding: 24, spacing: 24)
│ ├── HStack (top)
│ │ ├── Text "SETTINGS", 22pt heavy condensed, cyan
│ │ ├── Spacer
│ │ └── Button "✕" (SF Symbol "xmark"), cyan, tap → dismiss sheet
│ ├── Divider (cyan, opacity 0.2)
│ ├── SettingsRow "Music" — Toggle (bound to GameState.musicEnabled)
│ ├── SettingsRow "Sound Effects" — Toggle (bound to GameState.sfxEnabled)
│ ├── SettingsRow "Haptics" — Toggle (bound to GameState.hapticsEnabled)
│ ├── Divider (cyan, opacity 0.2)
│ ├── Text "FREEFALL v1.0", 12pt, white, opacity 0.3, centre aligned
│ └── Spacer
└── End
```
SettingsRow is a reusable component: HStack with label (left, 16pt, white) and Toggle (right,
tinted world primary colour).
### 5.3 Navigation Flow — All User Journeys
**First-time user:**
App launch → MainMenuView → tap PLAY → WorldSelectView (World 1 unlocked, 2-4
locked) → tap THE BLOCK → LevelSelectView (Level 1 pulsing, 2-10 locked) → tap Level 1→ GameView (Ready state) → tap to launch → play → [complete or die and retry] →
LevelCompleteView → tap NEXT LEVEL → GameView Level 2 → …
**Returning user (mid-progress):**
App launch → MainMenuView → tap PLAY → WorldSelectView → tap unlocked world →
LevelSelectView → tap next unlocked level → GameView → play
**Completing a world:**
GameView Level 10 → LevelCompleteView (“NEXT WORLD →”) → WorldSelectView (next
world now unlocked, card lights up)
**Quitting mid-level:**
GameView → tap pause → QUIT → LevelSelectView (no progress saved for incomplete
level)
**Toggling settings:**
MainMenuView → tap gear → SettingsView (sheet) → toggle music/sfx/haptics → dismiss
→ MainMenuView
**Quick music toggle:**
MainMenuView → tap speaker icon → music toggles immediately (no navigation)
### 5.4 Data Model
**GameState (@Observable class — single source of truth)**
```
Properties:
- completedLevels: Set<String> // Format: "W1L3" (World 1, Level 3)
- musicEnabled: Bool // Default: true
- sfxEnabled: Bool // Default: true
- hapticsEnabled: Bool // Default: true
- currentWorldId: Int? // Set when entering a world
- currentLevelId: Int? // Set when entering a level
- gameplayState: GameplayState // .ready, .playing, .dead, .complete, .paused
Computed properties:
- func isLevelUnlocked(world: Int, level: Int) -> Bool
// Level 1 always unlocked if world is unlocked
// Level N unlocked if "W{world}L{N-1}" is in completedLevels
- func isWorldUnlocked(world: Int) -> Bool
// World 1 always unlocked
// World N unlocked if all 10 levels of World N-1 are in completedLevels
- func completedCountForWorld(world: Int) -> Int
Persistence:
- completedLevels: stored in UserDefaults as JSON-encoded [String]
- musicEnabled, sfxEnabled, hapticsEnabled: stored as individual UserDefaults bools- currentWorldId, currentLevelId, gameplayState: NOT persisted (runtime only)
```
**LevelDefinition (struct — loaded from JSON)**
```
Properties:
- worldId: Int
- levelId: Int
- launchPosition: CGPoint // Normalised 0-1
- launchVelocity: CGVector // Points per second
- goalPosition: CGPoint // Normalised 0-1
- goalRadius: CGFloat // Points
- initialGravityDown: Bool
- parFlips: Int // Expected minimum flips for "optimal" solution
- obstacles: [ObstacleDefinition]
ObstacleDefinition:
- type: String // "rect", "circle", "polygon", "line"
- position: CGPoint // Normalised 0-1
- size: CGSize // Normalised (for rect)
- radius: CGFloat? // For circle
- points: [CGPoint]? // For polygon
- rotation: CGFloat // Degrees
- style: String // "neon_outline", "textured", "pulsing", "abstract"
```
**WorldDefinition (struct — hardcoded or from JSON)**
```
Properties:
- id: Int
- name: String // "THE BLOCK", "NEON YARD", etc.
- primaryColour: Color // hex
- secondaryColour: Color
- accentColour: Color
- trailStartColour: Color
- trailEndColour: Color
- musicFileName: String
- backgroundImageName: String
```
### 5.5 Design System
**Colours:**
|Token |Hex |Usage |
|---------------|-------------|----------------------------------||background |#000000 |All screen backgrounds |
|world1Primary |#00D4FF |World 1 UI elements, text, borders|
|world1Secondary|#1A1A2E |World 1 background tint |
|world1Accent |#FF1493 |World 1 trail end colour |
|world2Primary |#39FF14 |World 2 UI elements |
|world2Secondary|#1A1A0A |World 2 background tint |
|world2Accent |#FFE600 |World 2 trail end |
|world3Primary |#FF6600 |World 3 UI elements |
|world3Secondary|#1A0A00 |World 3 background tint |
|world3Accent |#CC0000 |World 3 trail end |
|world4Primary |#8B00FF |World 4 UI elements |
|world4Secondary|#0A000A |World 4 background tint |
|world4Accent |#FFFFFF |World 4 trail end |
|textPrimary |#FFFFFF |Primary text |
|textSecondary |#FFFFFF @ 50%|Secondary / hint text |
|sphere |#FFFFFF |Player sphere core |
|goalRing |#00FFFF |Goal ring |
**Typography:**
|Usage |Font |Size|Weight |
|-------------------------------|-------------------------------------|----|-------|
|Game title (FREEFALL) |System condensed or custom (see note)|64pt|Black |
|World names on cards |Same |28pt|Heavy |
|Level complete word (CLEAN etc)|Same |56pt|Black |
|PLAY button |Same |28pt|Heavy |
|Screen titles |Same |22pt|Heavy |
|Body text / labels |System |16pt|Regular|
|Level numbers (select grid) |System |24pt|Bold |
|In-game HUD (level number) |System monospaced |16pt|Medium |
|Small labels / captions |System |12pt|Regular|
**Font note:** The ideal font is a heavy condensed sans-serif — think Impact, Anton, Oswald
Black, or Barlow Condensed Black. At MVP, use the system `.title` with `.condensed` width
design. Post-launch, license or find a free condensed black font that has more street energy.
The font choice is cosmetic, not architectural — easy to swap later.
**Spacing:**
- Base unit: 8pt
- Standard padding: 24pt (3 units)
- Card spacing: 16pt (2 units)
- Button padding: 16pt horizontal, 12pt vertical
- Corner radius (cards): 12pt
- Corner radius (buttons): 8pt
- Corner radius (level cells): 8pt
**Haptics:**|Event |Generator |Style |
|-------------|-------------------------------|--------|
|Gravity flip |UIImpactFeedbackGenerator |.medium |
|Goal reached |UINotificationFeedbackGenerator|.success|
|Player death |UIImpactFeedbackGenerator |.soft |
|UI button tap|UIImpactFeedbackGenerator |.light |
### 5.6 Reusable Components
**WorldCard** — Used on WorldSelectView
- Props: worldId, name, primaryColour, isUnlocked, completedCount
- Appearance: horizontal card, 120pt height, full width, border in primaryColour, world name
text, lock icon if locked, dimmed if locked
- Behaviour: tap navigates to LevelSelectView if unlocked
**LevelCell** — Used on LevelSelectView
- Props: worldId, levelId, primaryColour, isCompleted, isUnlocked, isNextToPlay
- Appearance: square cell, 3 visual states (completed with checkmark, unlocked with pulsing
border, locked dim)
- Behaviour: tap loads level if unlocked
**SettingsRow** — Used on SettingsView
- Props: label (String), isOn (Binding<Bool>), tintColour (Color)
- Appearance: HStack with label and toggle
**NeonText** — Used for titles and completion words
- Props: text, fontSize, colour, glowRadius
- Appearance: text with outer shadow/glow in the specified colour
### 5.7 Paint Trail Technical Spec (for Codex)
**Rendering approach:**
Option A (recommended): Use `SKShapeNode` with a `CGMutablePath`. Every physics
frame, append the sphere’s position to the path. Set the path’s `strokeColor` using a gradient
(approximate by creating multiple path segments with different colours). Set `lineWidth` with
random variation. Add `SKEmitterNode` particles at the current position for spray effect.
Option B (performance fallback): Render trail to an `SKTexture` at intervals. Every N frames,
render the current trail to a bitmap texture and replace the path with this texture. This caps
the node count but adds rendering complexity.
**Trail colour interpolation:**- Track total distance travelled by the sphere during the level
- Map distance to a 0→1 parameter `t`
- Trail colour = lerp(worldTrailStartColour, worldTrailEndColour, t)
- At the beginning of a level the trail is the start colour. By the time the player reaches the
goal, it’s the end colour. Death resets `t` to 0.
**Spray-paint scatter effect:**
- At the sphere’s current position each frame, spawn 1-3 tiny `SKSpriteNode` circles (radius
1-3pt)
- Offset each by a random vector within 8-12pt of the trail centre
- Opacity: 0.15-0.35 (random)
- Colour: same as current trail colour
- These nodes do NOT fade — they persist like the trail
- Performance note: these accumulate. Cap at 2000 scatter nodes per level attempt. After
cap, stop spawning new scatter but trail path continues.
**On death:**
- All trail nodes (path + scatter) fade opacity to 0 over 0.3 seconds
- Then remove all trail nodes
- Reset trail colour parameter `t` to 0
**On level complete:**
- Trail remains visible
- Optional: slight camera zoom-out (scale game scene to 0.85 over 0.5 seconds) to reveal
more of the trail composition
- The trail IS the art. Do not obscure it with UI elements except the completion word (which
overlays on top) and the NEXT LEVEL button (small, bottom corner)
### 5.8 Build Order (for Codex)
Execute in this exact order. Do not skip ahead.
```
Step 1: Project setup
→ Create Xcode project, SwiftUI app, add SpriteKit framework
→ Deployment target: iOS 17.0
→ Devices: iPhone + iPad
→ No third-party packages
Step 2: GameState model
→ @Observable class with all properties from section 5.4
→ UserDefaults persistence for completedLevels, settings
→ Requires: Step 1Step 3: LevelDefinition model + JSON loading
→ Struct definitions from section 5.4
→ JSON decoder for level files
→ Create 1 test level JSON file (World 1, Level 1)
→ Requires: Step 1
Step 4: GameScene (SpriteKit) — sphere + gravity
→ SKScene subclass
→ Sphere node with physics body
→ Gravity toggling on touch
→ Haptic feedback on flip
→ Requires: Steps 1, 3
Step 5: Obstacle loading + rendering
→ Read obstacles from LevelDefinition
→ Create SKShapeNode or SKSpriteNode for each obstacle
→ Attach physics bodies (static)
→ Style per world (start with neon_outline only)
→ Requires: Steps 3, 4
Step 6: Collision detection
→ Sphere contacts obstacle → death
→ Sphere exits screen bounds → death
→ Sphere enters goal trigger → complete
→ Requires: Steps 4, 5
Step 7: Death sequence
→ Particle burst (SKEmitterNode)
→ Trail fade + clear
→ Auto-restart to Ready state
→ Requires: Step 6
Step 8: Paint trail system (basic)
→ SKShapeNode with CGPath
→ Colour gradient based on distance
→ Width variation
→ Requires: Step 4
Step 9: Paint trail spray effect
→ Scatter particles along trail
→ Edge bleed emitters
→ Performance cap at 2000 scatter nodes
→ Requires: Step 8
Step 10: Level complete sequence
→ Goal celebration (ring flash + particles)
→ Trail remains visible
→ Completion word selection logic→ Notify GameState
→ Requires: Steps 6, 8
Step 11: SwiftUI ↔ SpriteKit bridge
→ SpriteView embedding GameScene
→ GameState shared between SwiftUI and SpriteKit
→ SwiftUI observes gameplayState changes
→ Requires: Steps 2, 4
Step 12: MainMenuView
→ Layout per section 5.2
→ Navigation to WorldSelectView and SettingsView
→ Requires: Step 2
Step 13: WorldSelectView
→ Layout per section 5.2
→ World cards with lock state
→ Navigation to LevelSelectView
→ Requires: Steps 2, 12
Step 14: LevelSelectView
→ Layout per section 5.2
→ Level cells with 3 states
→ Navigation to GameView
→ Requires: Steps 2, 13
Step 15: GameView (SwiftUI wrapper)
→ Full screen cover presenting SpriteKitView
→ Observes GameState for level complete / quit
→ Requires: Steps 11, 14
Step 16: LevelCompleteView
→ Modal overlay on GameView
→ Completion word with animation
→ NEXT LEVEL / NEXT WORLD / LEVELS navigation
→ Requires: Steps 10, 15
Step 17: SettingsView
→ Sheet with toggles
→ Bound to GameState settings
→ Requires: Steps 2, 12
Step 18: Audio engine
→ AVAudioPlayer for music (looping, per-world tracks)
→ SKAction for SFX
→ Crossfade on world transition
→ Respect musicEnabled / sfxEnabled settings
→ Requires: Step 2Step 19: Level content — all 40 levels
→ Design and create JSON for worlds 1-4, levels 1-10 each
→ Follow difficulty curve from engagement science section
→ Requires: Steps 5, 6, 8 (need full engine to playtest)
Step 20: World visual themes
→ Background images per world
→ Obstacle styles per world (outline → texture → glow → abstract)
→ Trail colours per world
→ Requires: Steps 5, 8, 19
Step 21: iPad adaptive layout
→ Test all SwiftUI screens on iPad
→ Test game scene scaling on iPad aspect ratios
→ Adjust safe areas, padding, font sizes if needed
→ Requires: All previous steps
Step 22: Polish pass
→ Animations, transitions, particle tuning
→ Performance profiling (60fps target)
→ Accessibility: VoiceOver labels on all interactive elements
→ Requires: All previous steps
Step 23: App Store preparation
→ App icon (1024×1024)
→ Screenshots (6.7" and 6.1" iPhone, iPad)
→ App Store description, keywords, category
→ Privacy policy URL (required — can be a simple static page)
→ Requires: All previous steps
```
### 5.9 Tech Constraints (non-negotiable — repeat from context doc)
- SwiftUI only — no UIKit (except for haptic generators which require UIKit import)
- SpriteKit for all physics and game rendering
- @Observable for all state management (not ObservableObject/@Published)
- async/await for any async operations
- iOS 17+ minimum deployment target
- iPad layout required (adaptive, not just scaled iPhone)
- 2D only — no SceneKit, no Metal custom shaders, no 3D rendering
- No third-party packages without human approval first
- No backend, no API calls, fully offline
- Dark mode only (no light mode variant)
- Portrait orientation only
- Target: 60fps on iPhone 12 and above with full trail rendering
-----*End of blueprint. This document contains everything needed to go from zero to App Store
submission. Build Phase 1 first. If the flip + trail doesn’t feel incredible, stop and iterate.
Everything else is decoration on top of that core feel.*